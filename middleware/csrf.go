package middleware

import (
	"encoding/base64"
	"fmt"
	"github.com/clevergo/clevergo"
	"github.com/clevergo/clevergo/utils/string"
	"net/http"
	"strings"
)

var (
	errCSRFInvalid = "Unable to verify your data submission."
)

type CSRFMiddleware struct {
	Len          int
	Key          string
	SessionKey   string
	FormKey      string
	HeaderKey    string
	MaskLen      int
	SafeMethods  map[string]string
	ErrorInvalid string
}

func (csrf *CSRFMiddleware) Handle(next clevergo.Handler) clevergo.Handler {
	return clevergo.HandlerFunc(func(ctx *clevergo.Context) {
		var trueToken string
		if ctx.Session == nil {
			err := ctx.GetSession()
			if err != nil {
				panic(err)
			}
		}

		token, err := ctx.Session.Get(csrf.SessionKey)
		if (err != nil) || (token == nil) {
			trueToken = stringutil.GenerateRandomString(csrf.Len)
		} else {
			trueToken = token.(string)
		}

		if _, safe := csrf.SafeMethods[ctx.Request.Method]; !safe {
			if (len(trueToken) != csrf.MaskLen) &&
				!ValidateCSRFToken(csrf.MaskLen, ctx.Request.PostFormValue(csrf.FormKey), trueToken) &&
				!ValidateCSRFToken(csrf.MaskLen, ctx.Request.Header.Get(csrf.HeaderKey), trueToken) {
				ctx.Response.SetStatus(http.StatusBadRequest)
				ctx.Response.SetBody(csrf.ErrorInvalid)
				return
			}
		} else {
			csrfToken := GenerateCSRFToken(csrf.MaskLen, trueToken)
			ctx.Values[csrf.Key] = csrfToken
			ctx.Session.Set(csrf.SessionKey, trueToken)
			next.Handle(ctx)
		}
	})
}

func NewCSRFMiddleware() *CSRFMiddleware {
	return &CSRFMiddleware{
		Len:          32,
		Key:          "CSRFToken",
		SessionKey:   "_csrf",
		FormKey:      "_csrf",
		HeaderKey:    "X-CSRF-Token",
		MaskLen:      8,
		SafeMethods:  map[string]string{"GET": "", "HEAD": "", "OPTIONS": "", "TRACE": ""},
		ErrorInvalid: errCSRFInvalid,
	}
}

// Generate CSRF token.
// @maskLen length of mask.
// @token true token.
func GenerateCSRFToken(maskLen int, token string) string {
	// Generate mask string.
	mask := stringutil.GenerateRandomByte(maskLen)

	// XOR
	tokenByte := xorCSRFTokens([]byte(token), mask)

	// Base64 encoding.
	tokenStr := base64.StdEncoding.EncodeToString([]byte(string(mask) + string(tokenByte)))

	return strings.Replace(tokenStr, "+", ".", -1)
}

// Validate CSRF token.
// @maskLen length of mask.
// @token the token was generated by method named GenerateCsrfToken().
// @trueToken true token.
func ValidateCSRFToken(maskLen int, token, trueToken string) bool {
	// Restore the original base64 encoding string.
	token = strings.Replace(token, ".", "+", -1)

	// Base64 decoding.
	tokenByte, err := base64.StdEncoding.DecodeString(token)
	if err != nil {
		fmt.Println(err.Error())
		return false
	}

	// If the token is invalidï¼Œ returns false.
	token = string(tokenByte)
	if len(token) <= maskLen {
		return false
	}

	// Get mask by maskLen.
	mask := []byte(token)[0:maskLen]
	tokenByte = []byte(token)[maskLen:]

	// XOR
	token = string(xorCSRFTokens(mask, tokenByte))

	// Return true if the token is equals to trueToken.
	if 0 == strings.Compare(token, trueToken) {
		return true
	}

	// Otherwise false will be returned.
	return false
}

// XOR
func xorCSRFTokens(token1, token2 []byte) []byte {
	len1 := len(token1)
	len2 := len(token2)
	if len1 > len2 {
		for i := 0; i < len1-len2; i++ {
			token2 = append(token2, token2[i%len2])
		}
	} else {
		for i := 0; i < len2-len1; i++ {
			if len1 == 0 {
				token1 = append(token1, ' ')
			} else {
				token1 = append(token1, token1[i%len1])
			}
		}
	}
	token := []byte{}
	for i := 0; i < len(token1); i++ {
		token = append(token, token1[i]^token2[i])
	}
	return token
}
